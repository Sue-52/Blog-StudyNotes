"use strict";(self.webpackChunkvuepress_theme_reco_demo=self.webpackChunkvuepress_theme_reco_demo||[]).push([[8931],{8299:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-d554de1c",path:"/blogs/02.Leetcode/02.Leetcode%20Questions/day01-problems/01.Leetcode-Two%20Sum.html",title:"Leetcode-Two Sum",lang:"en-US",frontmatter:{title:"Leetcode-Two Sum",date:"2022-04-24T00:00:00.000Z",categories:["LeetCode"],tags:["LeetCode","Algorithm"]},excerpt:"",headers:[{level:2,title:"Leetcode-Two Sum（两数之和）",slug:"leetcode-two-sum-两数之和",children:[]},{level:2,title:"解题",slug:"解题",children:[{level:3,title:"解题思路一：暴力枚举（暴力破解法）",slug:"解题思路一-暴力枚举-暴力破解法",children:[]},{level:3,title:"解题思路二：哈希表（哈希表法）",slug:"解题思路二-哈希表-哈希表法",children:[]}]}],git:{createdTime:1650873872e3,updatedTime:1650873872e3,contributors:[{name:"Sue-52",email:"1219243947@qq.com",commits:1}]},filePathRelative:"blogs/02.Leetcode/02.Leetcode Questions/day01-problems/01.Leetcode-Two Sum.md"}},3515:(e,n,s)=>{s.r(n),s.d(n,{default:()=>l});const a=(0,s(6252).uE)('<h2 id="leetcode-two-sum-两数之和" tabindex="-1"><a class="header-anchor" href="#leetcode-two-sum-两数之和" aria-hidden="true">#</a> Leetcode-Two Sum（两数之和）</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 <code>两个</code> 整数，并返回它们的数组下标。</p><blockquote><p>Given an array of integers <code>nums</code> and an integer<code> target</code>, return indices of the two numbers such that they add up to target.</p></blockquote><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><blockquote><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p></blockquote><p>你可以按任意顺序返回答案。</p><blockquote><p>You can return the answer in any order.</p></blockquote><p><strong>Example 1:</strong></p><div class="language-JS ext-JS line-numbers-mode"><pre class="language-JS"><code>// Input: \nnums = [2,7,11,15], target = 9\n// Output: \n\t[0,1]\n// Explanation: \nBecause nums[0] + nums[1] == 9, we return [0, 1].\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>Example 2:</strong></p><div class="language-JS ext-JS line-numbers-mode"><pre class="language-JS"><code>// Input: \n  nums = [3,2,4], target = 6\n// Output: \n    [1,2]\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>Example 3:</strong></p><div class="language-JS ext-JS line-numbers-mode"><pre class="language-JS"><code>// Input: \n  nums = [3,3], target = 6\n// Output: \n    [0,1]\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="解题" tabindex="-1"><a class="header-anchor" href="#解题" aria-hidden="true">#</a> 解题</h2><h3 id="解题思路一-暴力枚举-暴力破解法" tabindex="-1"><a class="header-anchor" href="#解题思路一-暴力枚举-暴力破解法" aria-hidden="true">#</a> 解题思路一：暴力枚举（暴力破解法）</h3><p>最容易想到的方法是枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p><p>当我们使用遍历整个数组的方式寻找 <code>target - x</code> 时，需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p><div class="language-JavaScript ext-JavaScript line-numbers-mode"><pre class="language-JavaScript"><code>/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n// 暴力破解法\nvar twoSum = function (nums, target) {\n  for (let i = 0; i &lt; nums.length; i++) {\n    for (let j = i + 1; j &lt; nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n};\n\n// console.log(twoSum([2, 7, 11, 15], 9));\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O($N^2$)，其中 <code>N</code> 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h3 id="解题思路二-哈希表-哈希表法" tabindex="-1"><a class="header-anchor" href="#解题思路二-哈希表-哈希表法" aria-hidden="true">#</a> 解题思路二：哈希表（哈希表法）</h3><p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 <code>O(N)</code> 降低到 <code>O(1)</code>。</p><p>这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p><div class="language-JavaScript ext-JavaScript line-numbers-mode"><pre class="language-JavaScript"><code>/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n  // 创建 Map 存储数组中的元素和下标\n  map = new Map()\n  // 遍历数组\n  for (let i = 0; i &lt; nums.length; i++) {\n    // x 存储目标元素 - 当前元素\n    x = target - nums[i]\n    // 如果 Map 中存在 x 则返回 [x, i]\n    if (map.has(x)) {\n      // map.get 获取到 x 的下标\n      return [map.get(x), i]\n    }\n    // 将元素和下标存入 Map\n    map.set(nums[i], i)\n  }\n};\n\n// console.log(twoSum([2, 7, 11, 15], 9));\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div>',25),r={},l=(0,s(3744).Z)(r,[["render",function(e,n){return a}]])}}]);